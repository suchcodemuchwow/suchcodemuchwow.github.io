---
title: Introduction
description: Two Pointers Introduction

---

# Two-Pointer Technique

The two-pointer technique is a powerful approach used in array-based problems to efficiently find
solutions by maintaining two pointers (indices) that traverse the array. This method reduces time
complexity compared to using nested loops, making it ideal for problems involving sorted arrays or
specific patterns.

## Introduction

The two-pointer technique simplifies many array traversal problems by eliminating the need for nested
loops. It is particularly effective when:

1. The array is sorted.
2. You need to find pairs of elements that satisfy certain conditions.
3. You want to minimize time complexity (often O(n)).

### Basic Idea

- Use two pointers (`left` and `right`) to traverse the array from different directions.
- Adjust the pointers based on the problem's requirements to narrow down the search space.

## Common Patterns

### 1. Two Pointers Moving Towards Each Other

This pattern is useful for problems where you need to find pairs in a sorted array that sum up to a
specific value or condition.

#### Example:
**Problem:** Find two numbers in an array that add up to a target sum.
**Array:** [2, 4, 6, 8], **Target Sum:** 10
**Solution:** Use two pointers starting from both ends. If the sum is less than the target, move the left
pointer right; if the sum is greater, move the right pointer left.

```javascript
function twoSum(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        const sum = arr[left] + arr[right];
        if (sum === target) {
            return [arr[left], arr[right]];
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return null;
}
```

### 2. One Pointer Fixed and the Other Moving

This pattern is used when one element's value determines where to look next.

#### Example:
**Problem:** Find the first occurrence of a target element in an array.
**Array:** [1, 3, 5, 7, 9], **Target:** 5
**Solution:** Use one pointer starting from the beginning and move it until the target is found or the end
of the array is reached.

```javascript
function findFirstOccurrence(arr, target) {
    let i = 0;
    while (i < arr.length) {
        if (arr[i] === target) {
            return i;
        }
        i++;
    }
    return -1; // Target not found
}
```

### 3. Both Pointers Moving in the Same Direction

This pattern is useful when you need to find a window or subarray that satisfies certain conditions.

#### Example:
**Problem:** Find the smallest window with a sum greater than or equal to a target.
**Array:** [1, 4, 6, 8], **Target Sum:** 15
**Solution:** Use two pointers starting from the beginning and move them based on the current window's
sum.

```javascript
function findSmallestWindow(arr, target) {
    let left = 0;
    let minLen = Infinity;
    let currentSum = 0;

    for (let right = 0; right < arr.length; right++) {
        currentSum += arr[right];

        while (currentSum >= target && left <= right) {
            const windowLength = right - left + 1;
            if (windowLength < minLen) {
                minLen = windowLength;
            }
            currentSum -= arr[left];
            left++;
        }
    }

    return minLen === Infinity ? -1 : minLen;
}
```

## Problem-Solving Approach

### Steps to Apply Two-Pointer Technique:

1. **Identify Possible Pointer Movements:**
   - Left pointer can move right.
   - Right pointer can move left.
   - Both pointers can move in the same direction.

2. **Determine Conditions for Movement:**
   - Move left when the current sum is less than target.
   - Move right when the current sum is greater than target.

3. **Edge Cases:**
   - Handle empty arrays or null values.
   - Ensure pointers do not cross each other unless required by the problem.

## Example Questions

### 1. Valid Palindrome
**Problem:** Determine if a string is a palindrome, considering only alphanumeric characters and ignoring
cases.
**Solution:** Use two pointers starting from both ends of the string, moving towards the center while
skipping non-alphanumeric characters.

```javascript
function isPalindrome(s) {
    let left = 0;
    let right = s.length - 1;

    while (left < right) {
        // Skip non-alphanumeric characters
        while (!/[a-z]/i.test(s[left])) {
            left++;
        }
        while (!/[a-z]/i.test(s[right])) {
            right--;
        }

        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}
```

### 2. Remove Duplicates
**Problem:** Remove duplicates from a sorted array, allowing each element to appear only once.
**Solution:** Use two pointers where the second pointer moves only when a new unique element is found.

```javascript
function removeDuplicates(arr) {
    if (arr.length === 0) return 0;

    let left = 0;
    for (let right = 1; right < arr.length; right++) {
        if (arr[right] !== arr[left]) {
            left++;
        }
    }

    return left + 1;
}
```

## Conclusion

The two-pointer technique is a versatile method that simplifies many array-based problems. By maintaining
two pointers and adjusting them based on the problem's requirements, you can achieve efficient solutions
with linear time complexity. Practice different patterns to master this technique for your tech
interviews.

---

This content provides an in-depth understanding of the two-pointer technique, covering various patterns
and examples. You can use it as part of your tech interview preparation resources.